<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <title>폐·휴업 주유소 클러스터 지도</title>
    <link rel="stylesheet" href="main.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>

<body>
    <header class="navbar">
        <div class="search-container">
            <input type="text" id="search-input" placeholder="폐주유소 검색" autocomplete="off" />
            <button id="search-button">
                <span><img src="pngegg.png" alt="search" width="20" height="20"></span>
            </button>
            <ul id="suggestions"></ul>
        </div>
    </header>

    <div id="map"></div>

    <script>
        async function loadKakao() {
            let apiKey;
            const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
            if (isLocal) {
                apiKey = "65e1c8f1ab7fa043334d2b12c4bde905";
                console.log(" Local Kakao Key 사용중");
            }
            else {
                try {
                    const res = await fetch("/api/kakao");
                    const data = await res.json();
                    apiKey = data.key;
                    console.log(" Vercel Key 사용중");
                } catch (err) {
                    console.error("서버에서 키 받기 실패", err);
                    return;
                }
            }
            const script = document.createElement("script");
            script.src = `https://dapi.kakao.com/v2/maps/sdk.js?autoload=false&appkey=${apiKey}&libraries=services,clusterer`;
            script.onload = () => {
                console.log("✅ SDK script loaded:", !!window.kakao);
                kakao.maps.load(() => {
                    console.log("✅ kakao.maps.load callback fired");
                    initMap();
                });
            };

            document.head.appendChild(script);
        }

        loadKakao();
        let openOverlay = null;
        let closeTimer = null;
        function showDetailPanel(station) {
            document.getElementById("sidebar-name").textContent = station.name;
            document.getElementById("sidebar-addr").textContent = station.addr;
            document.getElementById("sidebar-status").textContent = station.status;

            const sidebar = document.getElementById("sidebar");
            sidebar.classList.remove("hidden");

            const pos = new kakao.maps.LatLng(station.lat, station.lng);
            const container = document.getElementById("roadview");
            container.innerHTML = "";
            const rv = new kakao.maps.Roadview(container);
            const rvc = new kakao.maps.RoadviewClient();

            rvc.getNearestPanoId(pos, 50, (panoId) => {
                if (panoId) rv.setPanoId(panoId, pos);
                else container.innerHTML = "<p style='padding:25px;text-align:center'>로드뷰 없음</p>";
            });
        }
        async function initMap() {
            let defaultCenter = new kakao.maps.LatLng(36.5, 127.8);
            let defaultLevel = 12;

            const savedCenter = localStorage.getItem("map_center");
            const savedLevel = localStorage.getItem("map_level");

            if (savedCenter) {
                const { lat, lng } = JSON.parse(savedCenter);
                defaultCenter = new kakao.maps.LatLng(lat, lng);
            }
            if (savedLevel) defaultLevel = parseInt(savedLevel);

            const map = new kakao.maps.Map(document.getElementById("map"), {
                center: defaultCenter,
                level: defaultLevel
            });


            kakao.maps.event.addListener(map, "center_changed", () => {
                const center = map.getCenter();
                const level = map.getLevel();
                localStorage.setItem("map_center", JSON.stringify({ lat: center.getLat(), lng: center.getLng() }));
                localStorage.setItem("map_level", level);
            });


            const clusterer = new kakao.maps.MarkerClusterer({
                map,
                averageCenter: true,
                minLevel: 7,
                disableClickZoom: false
            });

            const CSV_FILE = "station.csv";
            const stations = [];
            const markers = [];
            let polygons = [];

            const geoSources = {
                sido: "https://raw.githubusercontent.com/gajaeup/absolute/main/ctprvn_wgs84.geojson",
                sig: "https://raw.githubusercontent.com/gajaeup/absolute/main/sig_wgs84.geojson",
                emd: "https://raw.githubusercontent.com/gajaeup/absolute/main/emd_wgs84.geojson"
            };
            const geoData = {};

            for (const [key, path] of Object.entries(geoSources)) {
                try {
                    const res = await fetch(path);
                    geoData[key] = await res.json();
                    console.log(`✅ ${key} 레이어 로드 완료:`, geoData[key].features.length);
                } catch (err) {
                    console.error(`${key} GeoJSON 로드 실패`, err);
                }
            }

            Papa.parse(CSV_FILE, {
                download: true,
                header: true,
                skipEmptyLines: true,
                complete: (results) => {
                    const data = results.data;
                    const headers = results.meta.fields || Object.keys(data[0]);

                    function findColumnName(headers, candidates) {
                        for (const c of candidates) {
                            const idx = headers.findIndex(h => h && h.toLowerCase() === c.toLowerCase());
                            if (idx !== -1) return headers[idx];
                        }
                        for (const h of headers) {
                            if (!h) continue;
                            const s = h.toLowerCase();
                            for (const c of candidates) if (s.includes(c.toLowerCase())) return h;
                        }
                        return null;
                    }

                    const statusCol = findColumnName(headers, ["field4"]);
                    const nameCol = findColumnName(headers, ["field5"]);
                    const addrCol = findColumnName(headers, ["field6"]);
                    const latCol = findColumnName(headers, ["_Y"]);
                    const lngCol = findColumnName(headers, ["_X"]);

                    const seen = new Set();
                    data.reverse().forEach((row, idx) => {
                        const status = row[statusCol] || "";
                        if (!/휴업|폐업/.test(status)) return;

                        const lat = parseFloat(row[latCol]);
                        const lng = parseFloat(row[lngCol]);
                        if (isNaN(lat) || isNaN(lng)) return;

                        const key = `${lat},${lng}`;
                        if (seen.has(key)) return;
                        seen.add(key);

                        const name = row[nameCol] || "";
                        const addr = row[addrCol] || "";
                        stations.push({ name, addr, lat, lng });

                        const marker = new kakao.maps.Marker({
                            position: new kakao.maps.LatLng(lat, lng)
                        });

                        const color = /폐업/.test(status) ? "#ff5a5f" : "#ffb74d";
                        const infoHTML = `
          <div class="info-window" id="iw-${idx}">
            <div class="info-img"><img src="station_images/대림주유소.jpg" width="234" height="110"></div>
            <div class="info-body">
              <div class="info-name">${name || '(이름없음)'}</div>
              <div class="info-addr">주소: ${addr}</div>
              <div class="info-status">상태: <span class="status-badge" style="background:${color};">${status}</span></div>
            </div>
          </div>
        `;
                        const overlay = new kakao.maps.CustomOverlay({
                            position: marker.getPosition(),
                            content: infoHTML,
                            yAnchor: 1.5
                        });

                        kakao.maps.event.addListener(marker, "mouseover", () => {
                            if (closeTimer) {
                                clearTimeout(closeTimer);
                                closeTimer = null;
                            }
                            if (openOverlay) openOverlay.setMap(null);
                            overlay.setMap(map);
                            openOverlay = overlay;

                            setTimeout(() => {
                                const iw = document.getElementById(`iw-${idx}`);
                                if (!iw) return;

                                iw.addEventListener("mouseenter", () => {
                                    if (closeTimer) clearTimeout(closeTimer);
                                });
                                iw.addEventListener("mouseleave", () => {
                                    closeTimer = setTimeout(() => {
                                        if (openOverlay) openOverlay.setMap(null);
                                        openOverlay = null;
                                    }, 200);
                                });

                                iw.addEventListener("click", (e) => {
                                    e.stopPropagation();
                                    showDetailPanel({ name, addr, status, lat, lng });
                                    if (openOverlay) {
                                        openOverlay.setMap(null);
                                        openOverlay = null;
                                    }
                                });
                            }, 80);
                        });
                        kakao.maps.event.addListener(marker, "mouseout", () => {
                            closeTimer = setTimeout(() => {
                                const hoveredCard = document.querySelector(".info-window:hover");
                                if (!hoveredCard && openOverlay) {
                                    openOverlay.setMap(null);
                                    openOverlay = null;
                                }
                            }, 200);
                        });

                        markers.push(marker);
                    });
                    clusterer.addMarkers(markers);

                    // 검색 처리
                    const input = document.getElementById("search-input");
                    const button = document.getElementById("search-button");
                    const list = document.getElementById("suggestions");
                    button.onclick = handleSearch;
                    input.addEventListener("keypress", (e) => {
                        if (e.key === "Enter") handleSearch();
                    });

                    function handleSearch() {
                        const keyword = input.value.trim();
                        if (!keyword) return;

                        // 기존 폴리곤 제거
                        polygons.forEach(p => p.setMap(null));
                        polygons = [];

                        // 주유소 이름 검색
                        const foundStation = stations.find(s => s.name === keyword);

                        if (foundStation) {
                            const pos = new kakao.maps.LatLng(foundStation.lat, foundStation.lng);
                            map.setLevel(4);
                            map.panTo(pos);
                            return;
                        }

                        // ⭐ 2. 행정구역 검색
                        const matched = handleRegionSearch(keyword);
                        if (!matched) alert("일치하는 주유소나 행정구역이 없습니다.");
                    }

                    // ✅ 행정구역 검색 함수
                    function handleRegionSearch(keyword) {
                        const layers = [
                            { name: "시도", data: geoData.sido, key: "CTP_KOR_NM" },
                            { name: "시군구", data: geoData.sig, key: "SIG_KOR_NM" },
                            { name: "읍면동", data: geoData.emd, key: "EMD_KOR_NM" }
                        ];
                        for (const { name, data, key } of layers) {
                            if (!data) continue;
                            const match = data.features.find(f =>
                                f.properties[key] && f.properties[key].startsWith(keyword)
                            );

                            if (match) {
                                console.log(`✅ ${name} 매칭됨:`, match.properties[key]);
                                try {
                                    // ⭐ 매칭된 Feature만 drawPolygon으로 전달
                                    drawPolygon(match);
                                } catch (e) {
                                    // GeoJSON 구조 오류(치명적)는 여기서 잡고 콘솔에 출력합니다.
                                    console.error("❌ drawPolygon 함수 실행 중 치명적 오류 발생:", e);
                                }
                                return true;
                            }
                        }
                        return false;
                    }

                    function drawPolygon(feature) {
                        if (!feature || !feature.geometry || !feature.geometry.type) { return; }
                        const polygonPaths = [];

                        // --- 1. Polygon 타입 처리 (단순 경로) ---
                        if (feature.geometry.type === "Polygon") {
                            const coords = feature.geometry.coordinates[0];
                            const path = coords.map(([x, y]) => new kakao.maps.LatLng(y, x));
                            polygonPaths.push(path);
                        }

                        // ⭐⭐⭐ 2. MultiPolygon 타입 처리 (복잡 경로) ⭐⭐⭐
                        else if (feature.geometry.type === "MultiPolygon") {

                            // 이 블록 안에 MultiPolygon 처리 로직 전체를 넣습니다.
                            feature.geometry.coordinates.forEach(polygonBoundarySet => {
                                const outerBoundaryCoords = polygonBoundarySet[0];

                                if (outerBoundaryCoords && outerBoundaryCoords.length > 0) {
                                    const path = outerBoundaryCoords.map(([x, y]) => {
                                        const lat = parseFloat(y);
                                        const lng = parseFloat(x);
                                        if (isNaN(lat) || isNaN(lng)) return null;
                                        return new kakao.maps.LatLng(lat, lng);
                                    }).filter(p => p !== null);

                                    if (path.length > 0) {
                                        polygonPaths.push(path);
                                    }
                                }
                            });

                        }

                        // --- 3. 그 외 타입 처리 ---
                        else {
                            console.error("지원하지 않는 GeoJSON geometry 타입:", feature.geometry.type);
                            return;
                        }

                        // ⭐⭐⭐ 이하는 GeoJSON 처리 로직이 모두 끝난 후 실행됩니다. ⭐⭐⭐
                        if (polygonPaths.length === 0) return;

                        // ⭐ Kakao Maps Polygon은 MultiPolygon 처리를 위해 경로 배열의 배열을 허용합니다.
                        const polygon = new kakao.maps.Polygon({
                            path: polygonPaths, // 수정된 부분: polygonPaths 사용
                            strokeWeight: 2,
                            strokeColor: "#00695c",
                            strokeOpacity: 0.8,
                            fillColor: "rgba(0,150,136,0.35)",
                            fillOpacity: 0.6
                        });
                        polygon.setMap(map);
                        polygons.push(polygon);

                        const bounds = new kakao.maps.LatLngBounds();
                        polygonPaths.flat().forEach(p => bounds.extend(p)); // 경계 계산 시 flat() 사용
                        map.setBounds(bounds);
                        map.relayout();
                    }
                }
            }
            );
            document.getElementById("sidebar-close").onclick = () =>
                document.getElementById("sidebar").classList.add("hidden");
        }
    </script>
    <div id="sidebar" class="sidebar hidden">
        <div class="sidebar-header">
            <span id="sidebar-name"></span>
            <button id="sidebar-close">X</button>
        </div>

        <div class="sidebar-body">
            <p><strong>주소:</strong> <span id="sidebar-addr"></span></p>
            <p><strong>상태:</strong> <span id="sidebar-status"></span></p>

            <div id="roadview" class="roadview-box"></div>
        </div>
    </div>

</body>

</html>
